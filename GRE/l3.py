from math import comb


print('-------------------- 1 --------------------')
# Параметры задачи
n = 9  # количество испытаний
p = 0.2  # вероятность успеха
q = 1 - p  # вероятность неудачи

# Функция для вычисления вероятности P(X = k)
def binomial_probability(n, k, p):
    return comb(n, k) * (p ** k) * ((1 - p) ** (n - k))

# 1) Вероятность того, что не будут проданы 5 пакетов (X = 4)
prob_1 = binomial_probability(n, 4, p)

# 2a) Вероятность того, что будет продано менее 2 пакетов (X < 2)
prob_2a = sum(binomial_probability(n, k, p) for k in range(0, 2))

# 2b) Вероятность того, что будет продано не более 2 пакетов (X <= 2)
prob_2b = sum(binomial_probability(n, k, p) for k in range(0, 3))

# 2c) Вероятность того, что будет продано хотя бы 2 пакета (X >= 2)
prob_2c = 1 - prob_2a  # дополнение к вероятности "менее 2"

# 2d) Наивероятнейшее число проданных пакетов
# Наивероятнейшее число k определяется как целое число, ближайшее к (9 + 1) * 0.2
most_probable_k = round((n + 1) * p)

# Вывод результатов
print(f"1) Вероятность того, что не будут проданы 5 пакетов: {prob_1:.4f}")
print(f"2a) Вероятность того, что будет продано менее 2 пакетов: {prob_2a:.4f}")
print(f"2b) Вероятность того, что будет продано не более 2 пакетов: {prob_2b:.4f}")
print(f"2c) Вероятность того, что будет продано хотя бы 2 пакета: {prob_2c:.4f}")
print(f"2d) Наивероятнейшее число проданных пакетов: {most_probable_k}")

print('\n-------------------- 2 --------------------')
# Задача: Сколько раз необходимо подбросить игральную кость,
# чтобы наивероятнейшее выпадение тройки было равно 10?

# Вероятность выпадения тройки при одном подбрасывании
p = 1 / 6

# Наивероятнейшее число успехов
k_0 = 10

# Формула для нахождения минимального n:
# (n + 1) * p - 1 <= k_0 <= (n + 1) * p
# Решаем неравенство относительно n
n_min = int((k_0 + 1) / p - 1)  # Минимальное значение n

# Проверка результата
# При n = 65:
n = n_min
lower_bound = (n + 1) * p - 1  # Левая граница неравенства
upper_bound = (n + 1) * p      # Правая граница неравенства

# Вывод результатов с формулами и числовыми данными в комментариях
print(f"Минимальное количество подбрасываний n: {n}")
# Для n = 65:
# Левая граница: (n + 1) * p - 1 = (65 + 1) * (1/6) - 1 = 10
# Правая граница: (n + 1) * p = (65 + 1) * (1/6) = 11
print(f"Проверка: Левая граница = {lower_bound:.1f}, Правая граница = {upper_bound:.1f}")

print('\n-------------------- 3 --------------------')

# Задача: Сколько следует сыграть партий в шахматы с вероятностью победы в одной
# партии, равной 1/3, чтобы наивероятнейшее число побед было равно 5?

p = 1 / 3 # Вероятность победы в одной партии

k_0 = 5 # Наивероятнейшее число побед

# Формула для нахождения минимального n:
# (n + 1) * p - 1 <= k_0 <= (n + 1) * p
# Решаем неравенство относительно n
n_min = int((k_0 + 1) / p - 1)  # Минимальное значение n

# Проверка результата
# При n = 17:
n = n_min
lower_bound = (n + 1) * p - 1  # Левая граница неравенства
upper_bound = (n + 1) * p      # Правая граница неравенства

# Вывод результатов с формулами и числовыми данными в комментариях
print(f"Минимальное количество партий n: {n}")
# Для n = 17:
# Левая граница: (n + 1) * p - 1 = (17 + 1) * (1/3) - 1 = 5
# Правая граница: (n + 1) * p = (17 + 1) * (1/3) = 6
print(f"Проверка: Левая граница = {lower_bound:.1f}, Правая граница = {upper_bound:.1f}")

print('\n-------------------- 4 --------------------')

from math import comb

# Параметры задачи
n = 6  # количество телевизоров
p = 0.2  # вероятность того, что телевизор потребует ремонта
q = 1 - p  # вероятность того, что телевизор не потребует ремонта

# Функция для вычисления вероятности P(X = k)
def binomial_probability(n, k, p):
    return comb(n, k) * (p ** k) * ((1 - p) ** (n - k))

# а) Вероятность того, что не более одного телевизора потребует ремонта (X <= 1)
prob_a = sum(binomial_probability(n, k, p) for k in range(0, 2))  # P(X = 0) + P(X = 1)

# б) Вероятность того, что хотя бы один телевизор не потребует ремонта
# Это дополнение к вероятности того, что все телевизоры потребуют ремонта (X = 6)
prob_b = 1 - binomial_probability(n, 6, p)  # 1 - P(X = 6)

# Вывод результатов с формулами и числовыми данными в комментариях
print(f"а) Вероятность того, что не более одного телевизора потребует ремонта: {prob_a:.4f}")
# Для P(X = 0): C(6, 0) * (0.2)^0 * (0.8)^6 = 1 * 1 * 0.2621 = 0.2621
# Для P(X = 1): C(6, 1) * (0.2)^1 * (0.8)^5 = 6 * 0.2 * 0.3277 = 0.3932
# Итого: P(X <= 1) = 0.2621 + 0.3932 = 0.6553

print(f"б) Вероятность того, что хотя бы один телевизор не потребует ремонта: {prob_b:.4f}")
# Для P(X = 6): C(6, 6) * (0.2)^6 * (0.8)^0 = 1 * 0.000064 * 1 = 0.000064
# Итого: P(хотя бы один не потребует) = 1 - 0.000064 = 0.9999

