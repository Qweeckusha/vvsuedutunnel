from itertools import combinations
from math import comb

print("\n1. Вероятность того, что шары разного цвета")
# Задача: В урне 4 белых и 6 черных шаров, всего 10. Извлекаются 2 шара.
# Число благоприятных исходов (один белый и один чёрный): 4*6 = 24.
# Общее число исходов: C(10, 2) = 45.
# Вероятность = 24/45 = 8/15 ≈ 0.5333.
total = comb(10, 2)
diff_colors = comb(4, 1) * comb(6, 1)
print(diff_colors / total)

print("\n2. Вероятность составления пятизначного числа из 0,1,2,3,4")
# Задача: Рассматриваем пятизначное число, составленное только из цифр {0,1,2,3,4}.
# Первая цифра не может быть 0, значит вариантов для неё 4 (1,2,3,4),
# а для остальных 4 разряда – по 5 вариантов (так как 0 разрешён).
# Число благоприятных вариантов = 4 * 5^4 = 4 * 625 = 2500.
# Общее число пятизначных чисел = 90000 (числа от 10000 до 99999).
# Вероятность = 2500/90000 = 1/36 ≈ 0.02776.
print((4*5*5*5*5)/(9*10*10*10*10))

print("\n3. Вероятность не сдать хотя бы один экзамен")
# Студент сдает 3 экзамена с вероятностями успешной сдачи: 0.9, 0.65, 0.35.
# Вероятность успешной сдачи всех экзаменов = 0.9 * 0.65 * 0.35.
# Тогда вероятность не сдать хотя бы один экзамен = 1 - (0.9 * 0.65 * 0.35) = 0.79525.
p_fail = 1 - (0.9 * 0.65 * 0.35)
print(p_fail)

print("\n4. Вероятность правильного набора пароля")
# Задача: Пароль состоит из 7 цифр, и комбинация – строго возрастающая последовательность.
# Это означает, что для пароля необходимо выбрать 7 различных цифр из 10, порядок фиксирован (возрастание).
# Число таких комбинаций = C(10, 7) = 120.
# Вероятность угадать правильный пароль с первого раза = 1/120.
total_passwords = comb(10, 7)
valid_passwords = 1
print(valid_passwords / total_passwords)

print("\n5. Вероятность выпадения четного числа меньше 5")
# Задача: Бросается игральный кубик. Известно, что выпало число меньше 5, т.е. {1,2,3,4}.
# Из этих чисел чётные – 2 и 4 (2 числа).
# Вероятность = 2/4 = 0.5.
exodus = {1, 2, 3, 4}
favorable = {2, 4}
print(len(favorable) / len(exodus))

print("\n6. Вероятность выхода пассажиров")
# Задача:
# (а) Все выйдут на разных этажах: 19 * 18 * 17.
# (б) Ровно двое выйдут на одном этаже, а третий – на другом:
#     Выбираем этаж для пары (19 вариантов), затем другой этаж для оставшегося (18 вариантов),
#     и выбор пары из 3 человек: C(3,2) = 3. Итого: 19 * 18 * 3.
# (в) Все выйдут на одном этаже: 19 вариантов.
a = 19 * 18 * 17 / 19**3
b = 19 * 18 * 3 / 19**3
c = 19 / 19**3
print("На разных этажах",a ,"Два на одном этаже",b ,"Все на одном этаже",c )

print("\n7. Вероятность выбора короля и дамы")
# Задача: Из 36 карт выбирают 3. Требуется, чтобы среди выбранных была и карта-король, и дама.
# В колоде 4 короля и 4 дамы, остальные 36 - 8 = 28 карт.
print((comb(4, 1) * comb(4, 1) * comb(36-2, 1)) / comb(36, 3))

print("\n8. Вероятности выполнения плана прибыли")
# Задача: Три предприятия с вероятностями выполнения плана: p1 = 0.9, p2 = 0.95, p3 = 1.
# (а) Все выполнят план: p1 * p2 * p3.
# (б) Только два выполнят:
#     Первый выполнит, второй нет, либо второй выполнит, а первый нет.
# (в) Хотя бы одно: поскольку p3 = 1, гарантировано, что третье всегда успешно, значит вероятность = 1.
a = 0.9 * 0.95 * 1.0
b = (0.9 * 0.05 * 1) + (0.1 * 0.95 * 1)
c = (0.1 * 0.05 * 1) + a + b
print(a, b, c)

print("\n9. Вероятность ответа на все и хотя бы два вопроса")
# Задача:
# (а) Все отвечены: 0.9 * 0.9 * 0.8.
# (б) По крайней мере, два: сумма вероятностей "ровно 2 правильных" и "все 3 правильных".
a = 0.9 * 0.9 * 0.8
b = a + (0.9 * 0.9 * 0.2) + (0.9 * 0.8 * 0.1) + (0.8 * 0.9 * 0.1)
print(a, b)

print("\n10. Вероятность извлечения 10 копеек")
# Задача: Определить вероятность извлечения монеты достоинством в 10 копеек
# из левого кармана после перекладывания 5 монет из правого кармана.

# Общее количество монет в правом кармане:
total_right = 7  # Всего монет в правом кармане (3 монеты по 10 копеек + 4 монеты по 5 копеек)
coins_10_right = 3  # Количество монет по 10 копеек в правом кармане
coins_5_right = 4  # Количество монет по 5 копеек в правом кармане

# Количество монет, которые перекладываются из правого кармана в левый
transfer = 5

# Состояние левого кармана до перекладывания:
coins_10_left_initial = 3  # Количество монет по 10 копеек в левом кармане изначально
coins_5_left_initial = 4  # Количество монет по 5 копеек в левом кармане изначально
total_left_initial = coins_10_left_initial + coins_5_left_initial  # Общее количество монет в левом кармане изначально

# После перекладывания transfer монет из правого кармана в левый:
total_left_after = total_left_initial + transfer  # Новое общее количество монет в левом кармане

# Инициализация результирующей вероятности
prob_result = 0

# Рассматриваем все возможные варианты количества монет по 10 копеек (k),
# которые могут быть переложены из правого кармана в левый.
for k in range(1, coins_10_right + 1):  # k - количество монет по 10 копеек, перекладываемых из правого кармана
    if transfer - k > coins_5_right:  # Если для данного k невозможно взять столько монет по 5 копеек, пропускаем этот случай
        continue

    # Формула для числа способов выбрать k монет по 10 копеек и transfer - k монет по 5 копеек:
    # C(3, k) * C(4, 5 - k)
    ways = comb(coins_10_right, k) * comb(coins_5_right, transfer - k)

    # Формула для общего числа способов выбрать transfer монет из total_right монет:
    # C(7, 5)
    total_ways = comb(total_right, transfer)

    # Вероятность выбора конкретного сочетания монет (k монет по 10 копеек и transfer - k монет по 5 копеек):
    # P(k) = C(3, k) * C(4, 5 - k) / C(7, 5)
    prob_k = ways / total_ways

    # Вероятность вытянуть монету по 10 копеек из левого кармана после перекладывания:
    # P(вытянуть 10 копеек) = (3 + k) / (3 + 4 + 5)
    prob_draw = (coins_10_left_initial + k) / total_left_after

    # Добавляем вклад текущего случая в общую вероятность:
    # P(итоговая) += P(k) * P(вытянуть 10 копеек)
    prob_result += prob_k * prob_draw

# Выводим итоговую вероятность
print(prob_result)

print("\n11. Вероятность случайно выбрать отличную работу")
# Задача:
# Группа 1: 30 студентов, 8 "отлично" → вероятность = 8/30.
# Группа 2: 28 студентов, 6 "отлично" → вероятность = 6/28.
# Группа 3: 27 студентов, 9 "отлично" → вероятность = 9/27.
# Группа выбирается случайно (вероятность 1/3 для каждой), затем из выбранной группы случайно выбирается работа.
p_group = [30/85, 28/85, 27/85]
p_excellent = [8/30, 6/28, 9/27]
print(sum(p_group[i] * p_excellent[i] for i in range(3)))

print("\n12. Вероятность, что турист пошел по первой дороге")
# Задача: Турист на полянке выбирает одну из 5 дорог равновероятно (вероятность 1/5 для каждой).
p_exit = [0.6, 0.3, 0.2, 0.1, 0.1]
p_road = 1/5
p_success = sum(p_road * p for p in p_exit)
print((p_road * p_exit[0]) / p_success)

print("\n13. Вероятность, что деталь из цеха 1")
# Задача:
# Вероятность доброкачественной детали:
# P(хорошая) = 0.3*0.98 + 0.7*0.97.
# По формуле Байеса: P(цех 1 | деталь хорошая) = (0.3*0.98) / p_good.
p_good = (0.3 * 0.98 + 0.7 * 0.97)
print((0.3 * 0.98) / p_good)

print("\n14. Вероятность заправки грузовика")
# Задача: Общая вероятность заправки = 0.6*0.1 + 0.4*0.2.
p_truck = 3/5
p_gas_truck = 0.1
p_gas_car = 0.2
p_gas = p_truck * p_gas_truck + (1 - p_truck) * p_gas_car
print((p_truck * p_gas_truck) / p_gas)

print("\n15. Вероятности брака по заводам")
# Задача:
# Производство ламп:
# Завод 1: 1/3 ламп, вероятность брака = 0.2.
# Завод 2: 1/4 ламп, вероятность брака = 0.15.
# Завод 3: остальные лампы: 1 - (1/3 + 1/4) = 5/12, вероятность брака = 0.05.
p_defect = (1/3 * 0.2 + 1/4 * 0.15 + 5/12 * 0.05)
print((1/3 * 0.2) / p_defect, (1/4 * 0.15) / p_defect, (5/12 * 0.05) / p_defect)

print("\n16. Вероятность выявления нарушений")
# Задача: Определить вероятность того, что в ходе проверки будет установлен факт наличия
# банков с нарушениями в уплате налогов среди случайно выбранных трех банков.

# Общее количество банков в городе
total_banks = 28  # Всего банков

# Количество банков с нарушениями
violating_banks = 12  # Банков с нарушениями

# Количество банков без нарушений
non_violating_banks = total_banks - violating_banks  # Банков без нарушений

# Количество банков, которые выбираются для проверки
banks_to_check = 3

# Вероятность выявления нарушения в одном банке при проверке
detection_probability_per_bank = 0.7

# Общее число способов выбрать banks_to_check банков из total_banks:
# C(28, 3)
total_ways = comb(total_banks, banks_to_check)

# Инициализация результирующей вероятности
prob_detection = 0

# Рассматриваем все возможные варианты количества банков с нарушениями (k),
# которые могут быть выбраны для проверки.
for k in range(1, banks_to_check + 1):  # k - количество банков с нарушениями среди выбранных
    # Число способов выбрать k банков с нарушениями из violating_banks и
    # (banks_to_check - k) банков без нарушений из non_violating_banks:
    # C(12, k) * C(16, 3 - k)
    ways = comb(violating_banks, k) * comb(non_violating_banks, banks_to_check - k)

    # Вероятность выбора конкретного сочетания банков (k с нарушениями и остальные без):
    # P(k) = [C(12, k) * C(16, 3 - k)] / C(28, 3)
    p_k = ways / total_ways

    # Вероятность обнаружения хотя бы одного нарушения среди k банков с нарушениями:
    # P(обнаружение) = 1 - (вероятность не обнаружения во всех k банках)
    # P(обнаружение) = 1 - (1 - 0.7)^k = 1 - 0.3^k
    prob_found_in_k = 1 - (1 - detection_probability_per_bank) ** k

    # Добавляем вклад текущего случая в общую вероятность:
    # P(итоговая) += P(k) * P(обнаружение)
    prob_detection += p_k * prob_found_in_k

# Выводим итоговую вероятность
print(prob_detection)